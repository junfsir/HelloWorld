### 第1章 算法概述

#### 1.1 算法和数据结构

衡量算法好坏的两个重要标准：

- 时间复杂度
- 空间复杂度

数据结构是算法的基石，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。

数据结构的组成方式：

- 线性结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表；
- 树，包括二叉树，及由二叉树衍生出的二叉堆等；
- 图，多对多的关联关系；

#### 1.2 时间复杂度

运行时间的长短和占用内存空间的大小，是衡量程序好坏的重要因素；由于受运行环境和输入规模的影响，代码的绝对执行时间是无法预估的，但是可以预估代码的基本操作执行次数。

渐进时间复杂度：若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。因为渐进时间复杂度用大O来表示，所以也被称为大O表示法。

常见的时间复杂度按照从低到高的顺序，包括O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)等。

推导时间复杂度的原则：

- 如果运行时间是常数量级，则用常数1表示；
- 只保留时间函数中的最高阶项；
- 如果最高阶项存在，则省去最高阶项前面的系数；

#### 1.3 空间复杂度

和时间复杂度类似，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大O表示法。

程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数。

常见的空间复杂度按照从低到高的顺序，包括O(1)、O(n)、O(n^2)等。其中地柜算法的空间复杂度和递归深度成正比。

### 第2章 数据结构基础

#### 2.1 数组

数组是**有限个相同类型的变量**所组成的**有序**集合，数组中的每个变量被称为元素。

物理上，数组是一段连续完整的内存空间（顺序存储）。

数组读取元素和更新元素的时间复杂度都为O(1)。

插入元素：

- 尾部插入
- 中间插入
- 超范围插入

数组的扩容：新建一个数组，复制元素至新数组。

插入操作，数组扩容的时间复杂度是O(n)，插入并移动元素的时间复杂度也是O(n)，综合起来插入操作的时间复杂度是O(n)；删除操作，只涉及元素的移动，时间复杂度也是O(n)。

数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找出对应元素。有一种高效查找元素的算法叫作二分查找，就是利用数组的这个优势；至于数组的劣势，体现在插入和删除元素方面，由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

#### 2.2 链表

链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。

单向链表的每个节点包含两个部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。

链表的第一个节点被称为头结点，最后一个节点被称为尾结点，尾结点的next指针指向为空。

双向链表的每个节点除了拥有data和和next指针，还拥有指向前置节点的prev指针。

链表在内存中的存储方式是随机存储。

链表采用了见缝插针的方式，链表的每个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用零散的碎片空间。

基本操作：

- 查找节点：在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从头结点开始向后一个一个节点逐一查找。链表中的数据只能按顺序进行访问，最坏的时间复杂度是O(n)。

- 更新节点：如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可。

- 插入节点：

  - 尾部插入：把最后一个节点的next指针指向新插入的节点即可；
  - 头部插入：第一步，把新节点的next指向原先的头节点；第二步，把新节点变为链表的头节点；
  - 中间插入：第一步，新节点的next指针指向插入位置的节点；第二步，插入位置前置节点的next指针，指向新节点；

  只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要像数组那样考虑扩容的问题。

- 删除节点：

  - 尾部删除
  - 头部删除
  - 中间删除

  如果不考虑插入、删除之前的查找元素的过程，只考虑纯粹的插入和删除操作，时间复杂度都是O(1)。

> 数组的优势在于能够快速定位元素，对于读操作多、写操作少的场景来说，用数组更合适一些；相反地，链表的优势在于能够灵活地进行插入和删除操作，如果需要在尾部频繁插入、删除元素，用链表更合适一些。

#### 2.3 栈和队列

|   逻辑结构   | 线性结构[举例：顺序表、栈、队列] | 非线性结构[举例：数、图]     |
| :----------: | -------------------------------- | ---------------------------- |
| **物理结构** | **顺序存储结构[举例：数组]**     | **链式存储结构[举例：链表]** |

栈和队列都属于逻辑结构，它们的物理结构既可以利用数组，也可以利用链表来完成。

栈（stack）是一种线性数据结构，栈中的元素只能先入后出（FILO），最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。

栈的基本操作：

- 入栈：（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶；
- 出栈：（pop）就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶；

入栈和出栈只会影响到最后一个元素，不涉及其他元素的整体移动，所以无论是以数组还是以链表实现，入栈、出栈的时间复杂度都是O(1)。

队列（queue）是一种线性数据结构，不同于栈的先入后出，队列中的元素只能先入先出（FIFO）。队列的出口端叫作队头，队列的入口端叫作队尾。

队列的基本操作：

- 入队
- 出队

*栈的应用：*

栈的输入顺序和输出顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯历史；例如实现递归的逻辑，就可以使用栈来代替，因为栈可以回溯方法的调用链；栈还有一个著名的应用场景是面包屑导航，使用户在浏览器页面可以轻松地回溯到上一级或更上一级页面。

#### 2.4 散列表

散列表也叫作哈希表（hash table），这种数据结构提供了键和值的映射关系，只要给出一个key，就可以高效地查找到它所匹配的的value，时间复杂度接近于O(1)。

散列表在本质上也是一个数组。

哈希函数：按照数组长度进行取模运算。

### 第3章 树

3.1 树和二叉树

树（tree）是n（n>=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点：

- 有且仅有一个特定的称为根的节点；
- 当n>1时，其余节点可分为m（m>0）个互不相交的有限集，每个集合本身又是一个树，并称为根的子树；

树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下：

- 父节点
- 孩子节点
- 兄弟节点

树的最大层级数，被称为数的个高度或深度。

---

二叉树（binary tree）是树的一种特殊形式，这种树的每个节点**最多**有两个孩子节点。

二叉树节点的两个孩子节点，一个被称为左孩子，一个被称为右孩子。这两个孩子节点的顺序是固定的。

二叉树还有两种特殊形式：

- 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在统一层级上，这个树就是满二叉树；满二叉树的每个分支都是满的；
- 完全二叉树：对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n；如果这个树所有节点和同样深度的满二叉树的编号从1到n的节点位置完全相同，则这个二叉树称为完全二叉树；

二叉树应用：

- 查找
- 维持相对顺序

---

二叉查找树在二叉树的基础上增加了以下几个条件：

- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值；
- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值；
- 左右子树也都是二叉查找树；

对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜寻节点的时间复杂度就是O(logn)，和树的深度是一样的。

---

二叉排序树

---

二叉树的自平衡：红黑树、AVL树、数堆等；

---

#### 3.2 二叉树的遍历

从节点之间位置关系的角度来看，二叉树的遍历分为4种：

- 前序遍历：输出顺序是根节点、左子树、右子树；
- 中序遍历：输出顺序是左子树、根节点、右子树；
- 后序遍历：输出顺序是左子树、右子树、根节点；
- 层序遍历；

从更宏观的角度来看，二叉树的遍历归结为两大类：

- 深度优先遍历（前序遍历、中序遍历、后序遍历）；
- 广度优先遍历（层序遍历）；

前序、中序、后序遍历可用递归来实现；

#### 3.3  二叉堆

二叉堆本质上是一种完全二叉树，它分为2个类型：

- 最大堆：最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值；
- 最小堆：最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值；

二叉堆的根节点叫作堆顶；最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素，最小堆的堆顶是整个堆中的最小元素。

二叉堆的操作：

- 插入节点：当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置，然后节点上浮调整（时间复杂度O(logn)）；
- 删除节点：所删除的节点位于堆顶的节点，然后下沉调整（时间复杂度O(logn)）；
- 构建二叉堆：把一个完全无序的完全二叉树调整为二叉堆，本质就是所有非叶子节点依次下沉（时间复杂度O(n)）；

这几种操作都基于堆的自我调整，即把一个不符合堆性质的完全二叉树，调整成一个堆。

---

二叉堆虽然是一个完全二叉树，但它的存储并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组中。

二叉堆是实现堆排序及优先队列的基础。

#### 3.4 优先队列

优先队列不再遵循先入先出的原则，而是分为两种情况：

- 最大优先队列，无论入队列顺序如何，都是当前最大的元素优先出队；
- 最小优先队列，无论入队列顺序如何，都是当前最小的元素优先出队；

优先队列入队和出队的时间复杂度都是O(logn)。



