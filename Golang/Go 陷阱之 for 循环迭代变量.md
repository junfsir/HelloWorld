[Go 陷阱之 for 循环迭代变量](https://learnku.com/articles/26861)

捕获迭代变量
这是在学习 Go 程序设计 中遇到的一个比较重要的一个警告。这是个 Go 语言的词法作用域规则的陷阱。看完之后感觉是真的一个比较让人疑惑困惑的地方。所以特地记录一下。由标题就可以知道了，迭代变量，肯定是在 for 中遇到的问题。来看一个简单的例子说明一下这个问题所在。

看一段简单的代码， 首先是错误的示例：

```go
var slice []func()

func main() {
    sli := []int{1, 2, 3, 4, 5}
    for _, v := range sli {
        fmt.Println(&v)
        slice = append(slice, func(){
            fmt.Println(v * v) // 直接打印结果
        })
    }

    for _, val  := range slice {
        val()
    }
}
// 输出 25 25 25 25 25
```

你可能会很奇怪为什么会出现这种情况，结果不应该是 1, 4, 9, 16, 25 吗？其实原因是循环变量的作用域的规则限制。在上面的程序中，v 在 for 循环引进的一个块作用域内进行声明。在循环里创建的所有函数变量共享相同的变量，就是一个可访问的存储位置，而不是固定的值。(你会惊奇的发现 &v 的内存地址是一样的)

模拟一下实际的情况，假设 v 变量的地址在 0x12345678 上， for 循环在迭代过程中，所有变量值都是在这地址上迭代的。当最后调用匿名函数的时候，取值也是在这块地址上。所以最后输出的结果都是迭代的最后一个值。至少在 Go 语言中是不用质疑的。这里也是一个陷阱，如果你不清楚的话，肯定会遇到坑。那个该如何修改呢？

```go
var slice []func()

func main() {
    sli := []int{1, 2, 3, 4, 5}
    for _, v := range sli {
        temp := v // 其实很简单 引入一个临时局部变量就可以了，这样就可以将每次的值存储到该变量地址上
        fmt.Println(&temp) // 这里内存地址是不同的
        slice = append(slice, func(){
            fmt.Println(temp *  temp) // 直接打印结果
        })
    }

    for _, val  := range slice {
        val()
    }
}
// 输出 1, 4, 9, 16, 25 预期结果
```

只需要引入一个局部变量便可以解决了，这是必须的。否则你的程序将不会有可预期的结果。